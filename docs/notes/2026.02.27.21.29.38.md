## Signal — Spec proposal

### Spec: Static Observer Anti-Clump — Adaptive PI Guardrails (v1)

**Target file:** `fork_tales-main/part64/code/world_web/daimoi_observer.py`
**Target function(s):** `anti_clump_controller_config`, `anti_clump_controller_update`
**Intent:** reduce oscillations/ringing and mode-switch “kick” while keeping the existing PI structure + bounded `drive ∈ [-drive_limit, drive_limit]`.

---

### 1) Problem statement

`anti_clump_controller_update(...)` currently:

* integrates error every update (with some decay in-band), even when the actuator is saturated,
* has no deadband/hysteresis (chases noise),
* has no explicit `d(drive)/dt` bound (can jump when error spikes),
* carries a single integral state across control modes (`snr_valid` vs fallback), which can amplify mode-switch oscillation.

Result: when the plant has delay/noise (your sim does), PI can ring and “clump fights itself.”

---

### 2) Non-negotiable invariants (must remain true)

1. `drive` is always clamped to `[-drive_limit, +drive_limit]`.
2. integrals are always clamped to `[-integral_limit, +integral_limit]`.
3. CPU cost per controller update stays O(window) where window is small (<= 12).
4. All new behavior is **guardrail-only**: it can detune or smooth; it cannot violate caps.

---

### 3) Proposed changes

#### 3.1 Add a **slew-rate limiter** on `drive` (hard bound on dU)

**New config keys (controller):**

* `drive_slew_limit: float` (default `0.12`) — max absolute change in `drive` **per controller update**.
* `drive_slew_enabled: bool` (default `True`)

**Behavior:**
After computing the smoothed candidate drive:

* `candidate = clamp(prev*(1-smoothing) + raw*smoothing, -drive_limit, +drive_limit)`
* if enabled:
  `drive = prev + clamp(candidate - prev, -drive_slew_limit, +drive_slew_limit)`
  then clamp again to `[-drive_limit, +drive_limit]`

**Why:** even if PI spikes, the applied control is rate-limited → dramatically reduces ringing.

---

#### 3.2 Add **conditional integral** + leaky decay (anti-windup)

**New config keys:**

* `integral_enabled: bool` (default `True`)
* `integral_leak: float` (default `0.06`) — when frozen, do `integral *= (1 - integral_leak)`
* `integral_freeze_on_saturation: bool` (default `True`)
* `integral_saturation_epsilon: float` (default `0.02`) — treat as saturated if `abs(prev_drive) >= drive_limit - eps`
* `integral_freeze_on_sign_flip: bool` (default `True`)
* `integral_sign_stable_updates: int` (default `2`) — require same error sign for N controller updates before integrating

**Behavior:**

* Compute `error` exactly as today (snr vs fallback), but:

  * Determine `is_saturated`
  * Track `error_sign` and `sign_streak` in controller state
* Integrator update rules:

  * If `integral_enabled` is False → keep existing behavior (or leak)
  * Else if `integral_freeze_on_saturation` and `is_saturated` → leak integral
  * Else if `integral_freeze_on_sign_flip` and `sign_streak < integral_sign_stable_updates` → leak integral
  * Else integrate: `integral = clamp(integral + error, -integral_limit, +integral_limit)`
* Keep the existing “in-band decay” behavior for SNR mode, but run it *through the same freeze/leak gate*.

**Why:** most PI oscillation in discrete sims is windup + saturation + delayed response.

---

#### 3.3 Split integrators by mode (prevents mode-switch kick)

**New state keys (internal only, but safe to expose for debugging):**

* `integral_snr: float`
* `integral_score: float`
* `mode: str` in `{ "underpop", "snr", "score" }`

**Behavior:**

* If `particle_count < min_particles`: mode `underpop` (same as today; leak both integrals)
* Else if `snr_valid`: use `integral_snr` as the active integrator; leak `integral_score`
* Else: use `integral_score`; leak `integral_snr`
* Preserve existing external key `integral` as “active integral” (for UI/tests/summary).

**Why:** prevents an integral accumulated under one error definition from blasting the other regime.

---

#### 3.4 Add a **deadband** (stop chasing noise)

**New config keys:**

* `deadband_enabled: bool` (default `True`)
* `score_deadband: float` (default `0.03`) — applies to `score_ema - target`
* `snr_low_gap_deadband: float` (default `0.05`) — applies to `snr_low_gap` (already normalized)
* `deadband_integral_leak_boost: float` (default `0.10`) — extra leak when in deadband

**Behavior:**

* If in `score` mode and `abs(score_ema - target) < score_deadband`:

  * set `error = 0`, `raw_drive = 0`
  * leak integrals more aggressively
* If in `snr` mode and `snr_low_gap < snr_low_gap_deadband`:

  * same: settle, leak

**Why:** keeps controller quiet once “good enough,” avoids micro-oscillations.

---

#### 3.5 Add an “oscillation sentinel” → auto-detune gains (optional but recommended)

This is not “learning,” it’s a safety heuristic that only ever *reduces* aggressiveness when ringing is detected, then slowly returns to baseline.

**New config keys:**

* `adaptive_enabled: bool` (default `True`)
* `osc_window: int` (default `8`) — number of controller updates to keep
* `osc_zero_crossings_hi: int` (default `3`)
* `osc_sat_frac_hi: float` (default `0.5`)
* `gain_detune_kp_down: float` (default `0.85`)
* `gain_detune_ki_down: float` (default `0.70`)
* `gain_recover_kp_up: float` (default `1.03`)
* `gain_recover_ki_up: float` (default `1.02`)
* `kp_mult_min: float` (default `0.25`)
* `ki_mult_min: float` (default `0.10`)

**New state keys:**

* `error_hist: list[float]` (max length `osc_window`)
* `drive_hist: list[float]`
* `kp_mult: float` (starts `1.0`)
* `ki_mult: float` (starts `1.0`)
* `osc_zero_crossings: int`
* `osc_sat_frac: float`

**Heuristic:**

* Each controller update:

  * append `error`, `drive`
  * compute `zero_crossings(error_hist)`
  * compute `sat_frac` over drive_hist (`abs(drive) >= drive_limit - eps`)
* If `zero_crossings >= osc_zero_crossings_hi` OR `sat_frac >= osc_sat_frac_hi`:

  * `kp_mult = max(kp_mult_min, kp_mult * gain_detune_kp_down)`
  * `ki_mult = max(ki_mult_min, ki_mult * gain_detune_ki_down)`
* Else (stable):

  * `kp_mult = min(1.0, kp_mult * gain_recover_kp_up)`
  * `ki_mult = min(1.0, ki_mult * gain_recover_ki_up)`
* Use effective gains:

  * `kp_eff = kp * kp_mult`
  * `ki_eff = ki * ki_mult`

**Why:** when the loop rings, it backs off automatically; when calm, it returns to baseline.

---

### 4) Observability requirements (so you can debug it live)

Add to the controller state dict on update (and therefore into your summaries):

* `mode`
* `deadband_active: bool`
* `is_saturated: bool`
* `kp_eff`, `ki_eff`, `kp_mult`, `ki_mult`
* `osc_zero_crossings`, `osc_sat_frac`
* `slew_clamped: bool` (whether slew limiter applied that update)

These are lightweight and make it obvious *why* the controller did what it did.

---

### 5) Compatibility / safety

* All new keys are additive.
* Existing outputs (`drive`, `integral`, `error`, `score_ema`, metrics fields) remain.
* Default values are conservative and should reduce oscillation without breaking current tests (tests only validate ranges and presence of summary keys).

---

### 6) Verification plan

**Quick local checks**

1. Run existing tests:

   * `pytest fork_tales-main/part64/code/tests/test_daimoi_probabilistic.py`
   * `pytest fork_tales-main/part64/code/tests/test_c_double_buffer_backend.py`
2. Add one new unit test (recommended):

   * simulate alternating error sign in state and verify `kp_mult` drops and `integral` freezes/leaks.

**Runtime sanity**

* Watch `osc_zero_crossings` and `sat_frac` in the UI panel while forcing a high-clump scenario.
* Expect: `drive` changes smoothly, integrals don’t run away, and gain multipliers temporarily detune under ringing.
