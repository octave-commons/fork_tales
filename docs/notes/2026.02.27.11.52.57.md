## Goals and non-goals
**Goals**
- Provide a single command `/ralph-loop "<task>"` that runs in one interactive agent session and keeps going until the agent prints a completion marker. [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)
- Use a **completion promise** string (e.g. `DONE`) and require the model to emit it wrapped as `<promise>DONE</promise>` exactly. [x](https://x.com/mattpocockuk/status/2007924876548637089)
- When the agent attempts to stop without printing the promise, prevent termination and **reinject** the task with a reminder about the missing promise. [youtube](https://www.youtube.com/watch?v=74U04h9hQ_s)

**Non-goals**
- Not a multi-agent orchestrator, not parallel, not “new session per iteration,” not PRD-driven state management (those are different Ralph variants). [youtube](https://www.youtube.com/watch?v=J2thowAjPM0)

## User-facing CLI / slash command
Command shape (illustrative; adapt to your host CLI):
- `/ralph-loop "<task>" --max-iterations <N> --completion-promise "<PROMISE>" [--min-tool-calls <M>] [--on-promise-no-work <policy>]` [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)

Behavioral flags:
- `--completion-promise`: the raw token (e.g. `DONE`), used to construct the exact marker `<promise>${PROMISE}</promise>` for detection. [x](https://x.com/mattpocockuk/status/2007924876548637089)
- `--max-iterations`: hard stop to prevent infinite loops. [awesomeclaude](https://awesomeclaude.ai/ralph-wiggum)
- `--min-tool-calls` (default 1): mitigate “instant bypass” where the model immediately outputs the promise without doing work. [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)
- `--on-promise-no-work`: default `reject` (see “Bypass prevention”). [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)

## Core loop model (same session)
This is a **stop-hook loop**: the session continues normally while the agent works; the loop only intervenes when the agent tries to terminate. [youtube](https://www.youtube.com/watch?v=74U04h9hQ_s)

State tracked in memory by the plugin/command runtime:
- `taskPrompt: string` (the original user task)
- `promiseToken: string` (e.g. `DONE`)
- `promiseMarker: string = "<promise>" + promiseToken + "</promise>"`
- `iteration: number` starting at 0
- `maxIterations: number`
- `toolCallsThisRun: number` (count since loop started)
- `promiseSeen: boolean`
- `lastAssistantText: string` (last assistant message text, for scanning)

## Prompt contract (what you inject at start)
On entering `/ralph-loop`, inject a system/developer-style instruction (or equivalent high-priority message) that includes:
- The task text.
- The stopping rule: *Only when fully done*, output the exact promise marker `<promise>…</promise>`. [x](https://x.com/mattpocockuk/status/2007924876548637089)
- The “strictness” rule: must match exactly, no extra whitespace inside the tag, no variants. [youtube](https://www.youtube.com/watch?v=74U04h9hQ_s)
- The safety valve reminder: if not done, do not output the promise. [x](https://x.com/mattpocockuk/status/2007924876548637089)

This matches the common “strict requirements do not violate” framing described in walkthroughs of the approach. [youtube](https://www.youtube.com/watch?v=74U04h9hQ_s)

## Exit interception (the stop hook)
Your host needs a way to intercept “agent is trying to exit/finish.” The canonical Ralph-Wiggum implementations do this by preventing the exit and continuing the session (some descriptions mention using an exit code to block termination). [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)

### Hook algorithm
On attempted exit:
1. If `iteration >= maxIterations`: allow exit, return status `MAX_ITERATIONS_REACHED`. [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)
2. Scan all assistant output since loop start (or at minimum the final assistant message) for an exact match of `promiseMarker`. [x](https://x.com/mattpocockuk/status/2007924876548637089)
3. If the promise is found, apply bypass prevention rules (below). [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)
4. If accepted, allow exit, return status `PROMISE_ACCEPTED`.
5. If not found (or rejected), **block exit**, increment `iteration`, and inject a continuation message.

### Continuation message format (omo-style “reinject”)
Inject a single user-visible message like:
- “You attempted to end the loop, but you did not output the completion promise `<promise>DONE</promise>`. Continue working on the original task below. Only output the promise when the task is fully complete. Original task: …”

This matches your observed behavior (reinjecting original prompt + explanation) and aligns with “when you try to exit, the loop will feed the same prompt back…for the next iteration.” [youtube](https://www.youtube.com/watch?v=74U04h9hQ_s)

## Promise detection (exact match)
Detection must be strict:
- Accept only the exact substring `<promise>${PROMISE}</promise>` (case-sensitive). [x](https://x.com/mattpocockuk/status/2007924876548637089)
- Do not accept markdown code-fences variants unless you explicitly choose to (default: still accept if substring exists anywhere). [x](https://x.com/mattpocockuk/status/2007924876548637089)

Known failure mode to avoid:
- Some users reported the loop continuing even though `<promise>DONE</promise>` was present, implying the detector can be buggy or looking at the wrong buffer. [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1233)

## Bypass prevention (promise without work)
Add a rule: if promise is detected but the agent didn’t do any work, reject it and continue looping. [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)

Suggested default policy (matches the bug report’s implied fix):
- If `toolCallsThisRun < minToolCalls`, treat promise as invalid and inject: “Promise detected, but no tool calls/work were performed; you must actually complete the task before emitting the promise.” [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)

You can also implement a weaker heuristic if tool calls aren’t available:
- Require either (a) at least one tool call, or (b) at least one file diff / command output / test run evidence (host-dependent). [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)

## ULW-loop compatibility note (optional)
If you also implement a `/ulw-loop`, keep it identical to `/ralph-loop` except it prepends an “ultrawork mode” instruction to every continuation injection, per the stated difference between the two commands. [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1409)

## Observability + controls
- Provide `/cancel-ralph` (or similar) to force stop the loop immediately (manual escape hatch). [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)
- Log `iteration`, whether promise was found/rejected, and why (missing promise vs bypass). [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)

## Acceptance tests (black-box)
1. **Stops on promise**: Agent outputs `<promise>DONE</promise>` after doing work → loop exits with `PROMISE_ACCEPTED`. [x](https://x.com/mattpocockuk/status/2007924876548637089)
2. **Blocks exit without promise**: Agent says “I’m done” but no promise → exit blocked, reinjection occurs. [youtube](https://www.youtube.com/watch?v=74U04h9hQ_s)
3. **Max iterations**: Agent never outputs promise → exits after N iterations with `MAX_ITERATIONS_REACHED`. [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)
4. **Bypass rejected**: Agent immediately outputs `<promise>DONE</promise>` in first response with zero tool calls → promise rejected; continuation injected. [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)
5. **Promise detector correctness**: Promise appears in final message → loop must stop (guards against the “ignore promise tag” bug). [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1233)

## Minimal implementation surface (what you actually need)
- A command parser for `/ralph-loop`. [paddo](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)
- A stop/exit hook that can (a) inspect assistant output, (b) block termination, (c) inject a new message into the same session. [youtube](https://www.youtube.com/watch?v=74U04h9hQ_s)
- A strict substring detector for `<promise>…</promise>`. [x](https://x.com/mattpocockuk/status/2007924876548637089)
- Optional: tool-call counter for bypass prevention. [github](https://github.com/code-yeongyu/oh-my-opencode/issues/1921)
